"""Functions to communicate with bootloader."""
import logging
from dataclasses import dataclass
from typing import Dict, Iterator, Tuple, Type

import bincopy  # type: ignore[import-untyped]
from serial import Serial  # type: ignore[import-untyped]

from mcbootflash.error import (
    BadAddress,
    BadLength,
    BootloaderError,
    UnsupportedCommand,
    VerifyFail,
)
from mcbootflash.protocol import (
    Checksum,
    Command,
    CommandCode,
    MemoryRange,
    Response,
    ResponseBase,
    ResponseCode,
    Version,
)

_logger = logging.getLogger(__name__)

# Is this key always the same? Perhaps generated by MCC during code generation?
# If this key is incorrect, flash write operations will fail silently.
_FLASH_UNLOCK_KEY = 0x00AA0055


@dataclass
class BootAttrs:
    """Bootloader attributes."""

    version: int
    max_packet_length: int
    device_id: int
    erase_size: int
    write_size: int
    memory_range: Tuple[int, int]
    has_checksum: bool


def get_boot_attrs(connection: Serial) -> BootAttrs:
    """Read bootloader attributes from bootloader."""
    (
        version,
        max_packet_length,
        device_id,
        erase_size,
        write_size,
    ) = _read_version(connection)
    memory_range = _get_memory_address_range(connection)

    try:
        _get_remote_checksum(connection, memory_range[0], write_size)
        has_checksum = True
    except UnsupportedCommand:
        _logger.warning("Bootloader does not support checksumming")
        has_checksum = False

    return BootAttrs(
        version,
        max_packet_length,
        device_id,
        erase_size,
        write_size,
        memory_range,
        has_checksum,
    )


def chunked(
    hexfile: str, bootattrs: BootAttrs
) -> Tuple[int, Iterator[bincopy.Segments]]:
    hexdata = bincopy.BinFile()
    hexdata.add_microchip_hex_file(hexfile)
    hexdata.crop(*bootattrs.memory_range)
    chunk_size = bootattrs.max_packet_length - Command.get_size()
    chunk_size -= chunk_size % bootattrs.write_size
    chunk_size //= hexdata.word_size_bytes
    total_bytes = len(hexdata) * hexdata.word_size_bytes

    if not total_bytes:
        raise ValueError("HEX file contains no data within program memory range")

    total_bytes += (bootattrs.write_size - total_bytes) % bootattrs.write_size
    align = bootattrs.write_size // hexdata.word_size_bytes

    return total_bytes, hexdata.segments.chunks(chunk_size, align, b"\x00\x00")


def _read_version(connection: Serial) -> Tuple[int, int, int, int, int]:
    """Read bootloader version and some other useful information.

    Returns
    -------
    version : int
    max_packet_length : int
        The maximum size of a single packet sent to the bootloader,
        including both the command and associated data.
    device_id : int
    erase_size : int
        Flash page size. When erasing flash memory, the number of bytes to
        be erased must align with a flash page.
    write_size : int
        Write block size. When writing to flash, the number of bytes to be
        written must align with a write block.
    """
    read_version_response = _send_and_receive(
        connection,
        Command(CommandCode.READ_VERSION),
    )
    assert isinstance(read_version_response, Version)
    _logger.debug("Got bootloader attributes:")
    _logger.debug(f"Max packet length: {read_version_response.max_packet_length}")
    _logger.debug(f"Erase size:        {read_version_response.erase_size}")
    _logger.debug(f"Write size:        {read_version_response.write_size}")

    return (
        read_version_response.version,
        read_version_response.max_packet_length,
        read_version_response.device_id,
        read_version_response.erase_size,
        read_version_response.write_size,
    )


def _get_memory_address_range(connection: Serial) -> Tuple[int, int]:
    """Get the program memory range, i.e. the range of writable addresses.

    The returned tuple is suitable for use in `range`, i.e. the upper bound is not
    part of the writable range.
    """
    mem_range_response = _send_and_receive(
        connection,
        Command(CommandCode.GET_MEMORY_ADDRESS_RANGE),
    )
    assert isinstance(mem_range_response, MemoryRange)
    _logger.debug(
        "Got program memory range: "
        f"{mem_range_response.program_start:#08x}:"
        f"{mem_range_response.program_end:#08x}"
    )
    # program_end + 2 explanation:
    # +1 because the upper bound reported by the bootloader is inclusive, but we
    # want to use it as a Python range, which is half-open.
    # +1 because the final byte of the final 24-bit instruction is not included in
    # the range reported by the bootloader, but it is still writable.
    return mem_range_response.program_start, mem_range_response.program_end + 2


def erase_flash(
    connection: Serial,
    erase_range: Tuple[int, int],
    erase_size: int,
    force: bool = False,
    verify: bool = True,
) -> None:
    """Erase program memory area.

    Parameters
    ----------
    erase_range: tuple[int, int]
        Tuple of addresses forming a range to erase. The range is half-open,
        [start, end), i.e. the second address in the tuple is not erased.
    erase_size: int
        Size of a flash page, i.e. the smallest number of bytes which can be atomically
        erased.
    force : bool, optional
        By default, flash erase will be skipped if no program is detected in the
        program memory area. Setting `force` to True skips program detection and
        erases regardless of whether a program is present or not.
    verify : bool, optional
        The ERASE_FLASH command may fail silently if the `unlock_sequence` field of
        the command packet is incorrect. By default, this method verifies that the
        erase was successful by checking that no application is detected after the
        erase. Set `verify` to False to skip this check.

    Raises
    ------
    ValueError
        If `erase_range[1] - erase_range[0]` is not a multiple of `erase_size`.
    BootloaderError
        If an application is still detected after erase attempt.
    """
    start, end = erase_range

    if (end - start) % erase_size:
        raise ValueError("Address range is not a multiple of erase size")

    if force or _detect_program(connection):
        _logger.info("Erasing flash...")
        _logger.debug(f"Erasing addresses {start:#08x}:{end:#08x}")
        _send_and_receive(
            connection,
            command=Command(
                command=CommandCode.ERASE_FLASH,
                data_length=(end - start) // erase_size,
                unlock_sequence=_FLASH_UNLOCK_KEY,
                address=start,
            ),
        )
    else:
        _logger.info("No application detected, skipping flash erase")
        return

    if verify:
        if _detect_program(connection):
            _logger.debug("An application was detected; flash erase failed")
            _logger.debug("unlock_sequence field may be incorrect")
            raise BootloaderError("Existing application could not be erased")
        _logger.info("No application detected; flash erase successful")


def _detect_program(connection: Serial) -> bool:
    try:
        # Program memory may be empty, which should not be logged as an error.
        _logger.disabled = True
        self_verify(connection)
    except VerifyFail:
        return False
    finally:
        _logger.disabled = False

    return True


def write_flash(connection: Serial, chunk: bincopy.Segment) -> None:
    """Write data to bootloader.

    Parameters
    ----------
    chunk : bincopy.Segment
        A bincopy.Segment instance of length no greater than the bootloader's
        max_packet_length attribute.
    """
    _logger.debug(f"Writing {len(chunk.data)} bytes to {chunk.address:#08x}")
    _send_and_receive(
        connection,
        Command(
            command=CommandCode.WRITE_FLASH,
            data_length=len(chunk.data),
            unlock_sequence=_FLASH_UNLOCK_KEY,
            address=chunk.address,
        ),
        chunk.data,
    )


def self_verify(connection: Serial) -> None:
    _send_and_receive(connection, Command(command=CommandCode.SELF_VERIFY))
    _logger.info("Self verify OK")


def checksum(
    connection: Serial,
    chunk: bincopy.Segment,
    memory_range: Tuple[int, int],
) -> None:
    """Compare checksums calculated locally and onboard device.

    Parameters
    ----------
    segment : bincopy.Segment
        HEX segment to checksum.
    """
    # Workaround for bug in bootloader. The bootloader incorrectly raises BAD_ADDRESS
    # when trying to calculate checksums close to the upper bound of the program memory
    # range.
    if (memory_range[1] - chunk.address) < len(chunk.data):
        _logger.debug("Too close to upper memory bound, skipping checksum calculation")
        return

    checksum1 = _get_local_checksum(chunk)
    checksum2 = _get_remote_checksum(connection, chunk.address, len(chunk.data))

    if checksum1 != checksum2:
        _logger.debug(f"Checksum mismatch: {checksum1} != {checksum2}")
        _logger.debug("unlock_sequence field may be incorrect")
        raise BootloaderError("Checksum mismatch while writing")

    _logger.debug(f"Checksum OK: {checksum1}")


def _get_remote_checksum(connection: Serial, address: int, length: int) -> int:
    checksum_response = _send_and_receive(
        connection,
        Command(
            command=CommandCode.CALC_CHECKSUM,
            data_length=length,
            address=address,
        ),
    )
    assert isinstance(checksum_response, Checksum)
    return checksum_response.checksum


def _get_local_checksum(chunk: bincopy.Segment) -> int:
    chksum = 0

    for piece in chunk.chunks(
        size=4 // chunk.word_size_bytes,
    ):
        chksum += piece.data[0] + (piece.data[1] << 8) + piece.data[2]

    return chksum & 0xFFFF


def reset(connection: Serial) -> None:
    """Reset device."""
    _send_and_receive(connection, Command(command=CommandCode.RESET_DEVICE))
    _logger.info("Device reset")


def _read_flash(connection: Serial) -> None:
    raise NotImplementedError


def _get_response(connection: Serial, in_response_to: Command) -> ResponseBase:
    """Get a Response packet.

    Returns
    -------
    packet : ResponseBase
        An instance of a ResponseBase packet or a subclass thereof.
    """
    # Can't read the whole response in one go. Its length depends on whether it's an
    # error or not. Start by reading the command echo to determine the response
    # type.
    response = ResponseBase.from_bytes(connection.read(ResponseBase.get_size()))
    _logger.debug(f"RX: {_format_debug_bytes(bytes(response))}")

    if response.command != in_response_to.command:
        raise BootloaderError("Command code mismatch")

    response_type_map: Dict[CommandCode, Type[ResponseBase]] = {
        CommandCode.READ_VERSION: Version,
        CommandCode.READ_FLASH: Response,
        CommandCode.WRITE_FLASH: Response,
        CommandCode.ERASE_FLASH: Response,
        CommandCode.CALC_CHECKSUM: Checksum,
        CommandCode.RESET_DEVICE: Response,
        CommandCode.SELF_VERIFY: Response,
        CommandCode.GET_MEMORY_ADDRESS_RANGE: MemoryRange,
    }
    response_type = response_type_map[CommandCode(response.command)]

    # READ_VERSION has no 'success' flag.
    if response_type is Version:
        remainder = connection.read(response_type.get_size() - response.get_size())
        _logger.debug(f"RX: {_format_debug_bytes(remainder, bytes(response))}")
        return response_type.from_bytes(bytes(response) + remainder)

    success = connection.read(1)
    _logger.debug(f"RX: {_format_debug_bytes(success, bytes(response))}")

    if success[0] != ResponseCode.SUCCESS:
        bootloader_exceptions: Dict[ResponseCode, Type[BootloaderError]] = {
            ResponseCode.UNSUPPORTED_COMMAND: UnsupportedCommand,
            ResponseCode.BAD_ADDRESS: BadAddress,
            ResponseCode.BAD_LENGTH: BadLength,
            ResponseCode.VERIFY_FAIL: VerifyFail,
        }
        raise bootloader_exceptions[success[0]]

    response = Response.from_bytes(bytes(response) + success)
    remainder = connection.read(response_type.get_size() - response.get_size())

    if remainder:
        _logger.debug(f"RX: {_format_debug_bytes(remainder, bytes(response))}")

    response = response_type.from_bytes(bytes(response) + remainder)

    return response


def _send_and_receive(
    connection: Serial, command: Command, data: bytes = b""
) -> ResponseBase:
    msg = f"TX: {_format_debug_bytes(bytes(command))}"
    msg += f" plus {len(data)} data bytes" if data else ""
    _logger.debug(msg)
    connection.write(bytes(command) + data)
    response = _get_response(connection, command)

    return response


def _format_debug_bytes(debug_bytes: bytes, pad: bytes = b"") -> str:
    padding = " " * len(f"{' '.join(f'{b:02X}' for b in pad)}")
    padding += " " if padding else ""
    return f"{padding}{' '.join(f'{b:02X}' for b in debug_bytes)}"
