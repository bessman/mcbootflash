"""Command line tool for flashing firmware."""
from __future__ import annotations

import argparse
import logging
import shutil
import time
from typing import Iterator

from serial import Serial  # type: ignore[import-not-found]

import mcbootflash as mcbf

_logger = logging.getLogger(__name__)


def get_parser() -> argparse.ArgumentParser:
    """Parse arguments from command line.

    If `--version` is passed as an argument, print mcbootflash version and exit.

    Returns
    -------
    argparse.Namespace
        The returned ArgumentParser contains the following arguments::

            hexfile: str
            port: str
            baudrate: int
            timeout: float, default=5
            verbose: bool, default=False
            quiet: bool,  default=False
    """
    parser = argparse.ArgumentParser(
        description=(
            "Flash firmware over serial connection to a device running Microchip's "
            "16-bit bootloader."
        ),
    )
    parser.add_argument(
        "hexfile",
        type=str,
        help="An Intel HEX file containing application firmware",
    )
    parser.add_argument(
        "-p",
        "--port",
        type=str,
        required=True,
        help="Serial port connected to the device you want to flash",
    )
    parser.add_argument(
        "-b",
        "--baudrate",
        type=int,
        required=True,
        help="Symbol rate of device's serial bus",
    )
    parser.add_argument(
        "-t",
        "--timeout",
        type=float,
        default=5,
        help="Try to read data from the bus for this many seconds before giving up",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Print debug messages",
    )
    parser.add_argument(
        "-q",
        "--quiet",
        action="store_true",
        help="Suppress output",
    )
    parser.add_argument(
        "--version",
        action="version",
        version=f"{mcbf.__version__}",
    )
    return parser


def main(args: None | argparse.Namespace = None) -> None:
    """Entry point for CLI."""
    args = args if args is not None else get_parser().parse_args()
    loglevel = min(
        [
            logging.WARNING,
            logging.INFO + args.quiet * logging.WARNING,
            logging.DEBUG + (not args.verbose) * logging.WARNING,
        ],
    )
    logformat = logging.BASIC_FORMAT if loglevel == logging.DEBUG else "%(message)s"
    logging.basicConfig(level=loglevel, format=logformat)
    _logger.debug(f"mcbootflash {mcbf.__version__}")

    try:
        _logger.info("Connecting to bootloader...")
        connection = Serial(
            port=args.port,
            baudrate=args.baudrate,
            timeout=args.timeout,
        )
        bootattrs = mcbf.get_boot_attrs(connection)
        _logger.info("Connected")
        total_bytes, chunks = mcbf.chunked(args.hexfile, bootattrs)
        connection.timeout *= 10
        erase(connection, bootattrs.memory_range, bootattrs.erase_size)
        connection.timeout /= 10
        _logger.info(f"Flashing {args.hexfile}")
        flash(
            connection=connection,
            chunks=chunks,
            total_bytes=total_bytes,
            bootattrs=bootattrs,
        )
        mcbf.self_verify(connection)
        _logger.info("Self verify OK")
    except Exception as exc:  # noqa: BLE001
        _logger.error(exc)  # noqa: TRY400
        _logger.debug("", exc_info=True)


def erase(connection: Serial, erase_range: tuple[int, int], erase_size: int) -> None:
    """Erase flash if an application is detected, and verify erasure."""
    try:
        mcbf.self_verify(connection)
        _logger.info("Existing application detected, erasing...")
        mcbf.erase_flash(connection, erase_range, erase_size)
    except mcbf.VerifyFail:
        _logger.info("No application detected, skipping erase")
        return

    try:
        mcbf.self_verify(connection)
        msg = "Erase failed"
        raise mcbf.BootloaderError(msg)
    except mcbf.VerifyFail:
        _logger.info("Application erased")


def flash(
    connection: Serial,
    chunks: Iterator[mcbf.Chunk],
    total_bytes: int,
    bootattrs: mcbf.BootAttrs,
) -> None:
    """Flash application firmware.

    Parameters
    ----------
    connection : serial.Serial
        Open serial connection to device in bootloader mode.
    chunks : Iterator[bincopy.Segment]
        Appropriately sized chunks of data, as generated by `chunked.`.
    total_bytes : int
        Total number of bytes to be written.
    bootattrs : mcbf.BootAttrs
        Bootloader attributes, as read by `get_boot_attrs`.
    """
    written_bytes = 0
    start = time.time()

    for chunk in chunks:
        mcbf.write_flash(connection, chunk)

        if bootattrs.has_checksum:
            mcbf.checksum(connection, chunk)

        written_bytes += len(chunk.data)
        _logger.debug(
            f"{written_bytes} bytes written of {total_bytes} "
            f"({written_bytes / total_bytes * 100:.2f}%)",
        )
        # Only print progressbar if log level is exactly INFO, not higher or lower.
        loglevel: int = _logger.isEnabledFor(logging.INFO)
        loglevel += _logger.isEnabledFor(logging.DEBUG)

        if loglevel == 1:
            print_progress(written_bytes, total_bytes, time.time() - start)


def print_progress(written_bytes: int, total_bytes: int, elapsed: float) -> None:
    """Print progressbar.

    Parameters
    ----------
    written_bytes : int
        Number of bytes written so far.
    total_bytes : int
        Total number of bytes to write.
    elapsed : float
        Seconds since start.
    """
    ratio = written_bytes / total_bytes
    percentage = f"{100 * ratio:.0f}%"
    datasize = get_datasize(written_bytes)
    timer = get_timer(elapsed)
    progress = get_bar(
        ratio,
        len(percentage) + len(datasize) + len(timer) + 3 * len("  "),
    )
    print(  # noqa: T201
        percentage,
        datasize,
        progress,
        timer,
        sep="  ",
        end="\n" if written_bytes == total_bytes else "\r",
    )


def get_datasize(written_bytes: int) -> str:
    """Get human-readable datasize as string.

    Parameters
    ----------
    written_bytes : int
        Number of bytes written so far.

    Returns
    -------
    str
    """
    value: float = written_bytes
    decimals = 0

    for _prefix in ("", "Ki", "Mi"):
        next_prefix = 1000

        if value < next_prefix:
            break

        value /= 1024
        decimals = 1

    return f"{value:.{decimals}f} {_prefix}B"


def get_timer(elapsed: float) -> str:
    """Get a timer string formatted as H:MM:SS.

    Parameters
    ----------
    elapsed : float
        Time since start.

    Returns
    -------
    str
    """
    hours, minutes = divmod(elapsed, 3600)
    hours = int(hours)
    minutes, seconds = divmod(minutes, 60)
    minutes = int(minutes)
    seconds = int(seconds)
    return f"Elapsed Time: {hours}:{minutes:02}:{seconds:02}"


def get_bar(done_ratio: float, used_width: int) -> str:
    """Get progressbar string.

    Parameters
    ----------
    done_ratio : float
        A value between zero and one.
    used_width : int
        Number of characters already used by other elements.

    Returns
    -------
    str
    """
    max_width = min(shutil.get_terminal_size().columns, 80)
    bar_width = max_width - used_width - 2
    done = int(bar_width * done_ratio)
    left = bar_width - done
    return "|" + done * "#" + left * " " + "|"
